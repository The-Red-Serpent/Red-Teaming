### What is X.509
**X.509** is a **standard format for public key certificates**. These certificates are used to prove **identity** on the internet (like when you're using HTTPS).

## Structure of an X.509 Certificate

Each X.509 certificate contains **metadata and a public key**:

| Field                   | Description                                                         |
| ----------------------- | ------------------------------------------------------------------- |
| **Version**             | Which X.509 version is used (v1, v3 are common)                     |
| **Serial Number**       | Unique ID assigned by the Certificate Authority (CA)                |
| **Issuer**              | Who issued the certificate (e.g., Let's Encrypt)                    |
| **Subject**             | Who the certificate is issued to (e.g., google.com)                 |
| **Public Key**          | The subjectâ€™s public key                                            |
| **Signature Algorithm** | Algorithm used by the issuer to sign the cert (e.g., SHA256withRSA) |
| **Validity**            | Start and end time of cert's validity                               |
| **Extensions**          | Extra data like key usage, subject alt names (SANs), etc.           |

## What Is a Digital Certificate?

A **certificate** is a digital file that contains:

- The website's **identity** (domain, org name)
- Its **public key**
- Its **validity period**
- The **issuer** (who signed it)
- A **digital signature** proving it wasnâ€™t forged


### Who Signs These Certificates?

#### Certificate Authorities (CAs)

A **Certificate Authority** is a **trusted third party** that verifies identity and issues certificates.

**Examples:**

- Letâ€™s Encrypt (free)
- DigiCert
- GlobalSign
- GoDaddy
These are **pre-installed** in all OSes/browsers as **trusted root CAs**.

##### What Happens When You Visit an HTTPS Website?

1.  Server sends its **X.509 certificate**
2.  Your browser checks:
    - Is it **valid** (not expired)?
    - Is it **signed by a trusted CA**?
    - Is the **domain name correct**?    
3.  If yes â†’ browser sets up **encrypted TLS connection**

### When Certificates Are Not Used (or Validated)

### Scenario:

The app connects to `https://api.bank.com`, but does **not validate the serverâ€™s certificate** (or accepts any cert).

This means:
- It **doesnâ€™t check** if the cert is from a trusted CA
- It **doesnâ€™t check** the domain name
- It **doesnâ€™t care** if the cert is self-signed or fake

### What This Enables (Real Impact)

#### 1. **Man-in-the-Middle (MITM) Attacks**

An attacker intercepts the network using a rogue Wi-Fi or proxy (like Burp), and presents a **fake certificate**.

Because the app doesn't validate certs:
- It accepts the fake cert
- Establishes a **TLS connection with the attacker**
- Sends sensitive data like **passwords, tokens, credit card info** â€” all visible to the attacker
âœ… Even if HTTPS is being used, the attacker can fully decrypt the data.

### ðŸ”“ 2. **Session Hijacking & Data Tampering**

Since the attacker is in the middle:

- They can **read**, **modify**, or **inject** data into requests/responses
- They can **steal session cookies or tokens**
- They can **serve fake data** to the app
### 3. **No Integrity, No Authenticity**

The app has **no way to know** it's talking to the real server.

Examples:

- Fake update servers (malware injection)
- Cloned backend APIs (steal credentials)
- Fake banking pages (phishing inside the app)

### Self Signed Certificates
A self-signed certificate is one that is not signed by a CA at all â€“ neither private nor public. In this case, the certificate is signed with its own private key, instead of requesting it from a public or a private CA.
[for more](https://medium.com/@talyitzhak/understanding-digital-certificates-and-self-signed-certificates-b1cdca759bbc)

### Proxy Config In mobile
[Link](https://youtu.be/NDZKrpLqi0c?feature=shared)


