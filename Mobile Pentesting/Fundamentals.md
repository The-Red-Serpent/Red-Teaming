## Android Application Components 
<p align="justify">Application components are the essential building blocks of an Android application. Each component is a different point through which the system can enter your application. Not all components are actual entry points for the user and some depend on each other, but each one exists as its own entity and plays a specific role—each one is a unique building block that helps define your application’s overall behavior.</p>

### Activities

> An activity represents a single, full-screen user interface (UI) within your application.

An activity represents a single screen with a user interface, in-short Activity performs actions on the screen. For example, an email application might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails

### Services

> A Service is an application component that can perform long-running operations in the background, and it doesn't provide a user interface.

### Broadcast Receivers

> Broadcast receivers are lightweight components that listen for system-wide broadcast announcements. A listener for system-wide messages/events. Broadcast receivers are responsible for handling all the communication between the operating system and applications
[Read](https://medium.com/@khush.panchal123/understanding-broadcast-receivers-in-android-044fbfaa1330)

### Content Providers

Content providers act as a central hub for managing shared sets of application data. They allow other applications to access and potentially modify this data, if your content provider grants permission. A database interface to share data between apps.

### Intent
Android uses intent for communicating between the components of an Application and also from one application to another application.

<p align="justify">Intent are the objects which is used in android for passing the information among Activities in an Application and from one app to another also. Intent are used for communicating between the Application components and it also provides the connectivity between two apps.</p>

[for more](https://developer.android.com/guide/components/fundamentals#Components)

### Intent Filter
<p align="justify">An Intent Filter is a component used to declare the capabilities of a particular component (e.g., Activity, Service, or Broadcast Receiver) in your app. It allows your app to specify which types of intents it can handle, and it also defines the conditions under which the component can be activated to respond to incoming intents from other apps or system events. Intent filters are specified in the AndroidManifest.xml file of your app and play a crucial role in enabling communication between different components and apps.</p>


#### Types of Intents
##### Implicit Intent:
Implicit intents are used when you want to describe a general action to be performed, leaving it to the Android system to determine which component should handle the action based on its capabilities and the filter criteria specified in the intent.
Implicit intents are commonly employed for actions like sending an email, opening a web page, making a phone call, or sharing content. You don't need to specify a particular component; instead, the Android system presents the user with a list of apps capable of handling the requested action.

##### Explicit Intent:
Explicit intents are used when you want to explicitly specify the exact component (activity, service, or broadcast receiver) to be invoked. You precisely define the target component within your code.

##### Broadcast intent
A broadcast intent in the Android operating system is an `Intent` object that is disseminated system-wide to notify interested components of an event. Unlike intents used to start activities or services, broadcast intents are not directed at a specific component. Instead, they are a general announcement that any `BroadcastReceiver` registered to listen for that specific broadcast can receive and act upon.

##### Sticky Broadcast
A **Sticky Broadcast** in Android is a **type of broadcast intent** that **remains in the system after it has been sent**, so that future receivers can access the most recent broadcast **even if they register after the broadcast was sent**.

##### Pending Intent
[Read more](https://medium.com/androiddevelopers/all-about-pendingintents-748c8eb8619)

### Deep links
Deep inks are a concept that help users navigate between **the web** and **applications.** They are basically URLs which navigate users directly to the specific content in applications.
[Read](https://medium.com/@muratcanbur/intro-to-deep-linking-on-android-1b9fe9e38abd)
[read](https://www.adjust.com/blog/dive-into-deeplinking/)
[Read](https://www.vaadata.com/blog/what-are-deep-links-vulnerabilities-attacks-and-security-best-practices/)

### AIDL
**AIDL (Android Interface Definition Language)** is a way to define a programming interface in Android so that two different processes (for example, two different apps or different parts of the same app running separately) can communicate with each other using **Inter-Process Communication (IPC)**.

Since one process can’t directly access another’s memory, AIDL automatically generates the code needed to break down complex data into primitives (marshalling), send it across, and reassemble it on the other side letting the client and service interact as if they were calling normal methods.
[Read](https://medium.com/@peternjuguna76/understanding-android-aidl-a-comprehensive-guide-b4d97253b169)

### Messenger
**Messenger** is a helper in Android that lets two parts of your app (or even different apps) send **Message objects** to each other, especially for **IPC (Inter-Process Communication)**, without having to use AIDL.
[Read](https://proandroiddev.com/ipc-techniques-for-android-messenger-3e8555a32167})
[Read](https://divyaparashar.medium.com/messenger-ipc-mechanism-b1356b133c5c)

### Binder
[Read](https://medium.com/@python-javascript-php-html-css/understanding-binder-androids-optimized-ipc-mechanism-eb8f02dc4a68)
[Read](https://proandroiddev.com/android-binder-mechanism-the-backbone-of-ipc-in-android-6cfc279eb046)

### Web View
WebView in Android is a UI component that allows Android applications to display web content directly within the app's layout, without launching a separate web browser. It is essentially an embedded browser engine that can render HTML, CSS, and execute JavaScript. Webviews are vuln to all web appication vulnerabilities


### Android API Level:
In Android, every operating system version is assigned an **API level**, which is simply a numeric identifier that tells developers and pentesters which features and security controls are available on that device. While users usually see Android versions expressed as numbers (like Android 7, 8, 9) or codenames (Nougat, Oreo, Pie), developers work with API levels because they are unambiguous. For example, Android 7.0 corresponds to API level 24, Android 7.1 is API level 25, Android 8.0 is API 26, Android 8.1 is API 27, Android 9 is API 28, Android 10 is API 29, Android 11 is API 30, Android 12 is API 31, Android 12L is API 32, Android 13 is API 33, and Android 14 is API 34.

How to check android Api level and Android version
```
adb shell getprop ro.build.version.sdk     # API level
adb shell getprop ro.build.version.release # Android version
```
[Api levele.com](https://apilevels.com/)


## Android Architecture 

### 1. Linux Kernel (Bottom Layer - RED)

The **Linux Kernel** is the foundation of the Android OS. Think of it as the part that directly talks to the hardware.

### 🔧 Components:

- **Drivers**:
    
    - 📢 **Audio** – Controls speakers/microphone.
    - 🎮 **Keypad** – Reads input from hardware buttons.
    - 🎥 **Camera** – Talks to the device’s camera module.
    - 📺 **Display** – Controls screen output.
    - 📡 **Bluetooth, USB, WIFI** – Handle wireless/wired communication.
    - 🔄 **Binder (IPC)** – Allows apps to talk to system services securely.
    - 💾 **Shared Memory** – Allows parts of the system to share data quickly.
        
- **Power Management**:
    
    - Manages battery usage and makes sure apps and hardware components sleep or wake as needed.
        

> 🧠 **Key Idea**: The kernel is like the “control room” between the apps and the hardware.

---

### 2. HAL – Hardware Abstraction Layer (CYAN)

The HAL is like a **translator** between hardware drivers and higher-level Android components.

### 🔌 Examples:

- **Audio HAL** – Allows Android’s audio system to talk to speaker/mic drivers.
- **Camera HAL** – Connects Android’s Camera API to the hardware camera module.
- **Bluetooth HAL**, **Sensor HAL**, etc.
    

> 🧠 Think of HAL as plugins or adaptors that hide hardware complexity from the Android system.

---

### 3. Native C/C++ Libraries (PURPLE)

These are **powerful, fast system libraries written in C/C++**. Apps don’t directly use these, but Android system components and runtime use them.

### Key Libraries:

- **WebKit** – Used for rendering web pages (used by WebView).
- **OpenMAX AL** – Media codecs (audio/video decoding).
- **Libc** – Standard C library used by the system.
- **OpenGL ES** – For drawing 2D/3D graphics (used in games).
- **Media Framework** – Handles audio/video playback and recording.
    

> 🧠 These libraries give Android the ability to **play videos**, **render webpages**, **draw 3D graphics**, etc.

---

### 4. Android Runtime (YELLOW)

This part **runs your apps**.

### It has two parts:

- **ART (Android Runtime)**:
    
    - Executes your app’s Java/Kotlin code.
    - Replaces older Dalvik VM.
    - Uses **AOT (Ahead-of-Time)** and **JIT (Just-in-Time)** compilation to boost performance.
        
- **Core Libraries**:
    
    - Provide basic building blocks like data structures, file access, networking, etc. (similar to Java libraries).
        

> 🧠 ART is what makes your code actually run on the phone.

---

### 5. Java API Framework (GREEN)

This layer gives **developers the tools to build apps**.

### Key Parts:

- **View System** – Buttons, text boxes, UI components.
- **Content Providers** – Share data between apps (e.g., contacts, media).
- **Activity** – Represents one screen of an app.
- **Location** – Get GPS info.
- **Notification** – Show alerts/status bar messages.
- **Resource Manager** – Access strings, layouts, images, etc.
- **Telephony** – Make phone calls, manage SIM functions.
- **Window Manager** – Manages UI windows.
- **Package Manager** – Manages installed apps.
    

> 🧠 Developers use this layer (via Android SDK and Java/Kotlin) to create features, screens, and system interactions.

---

### 6. System Apps (TOP – BLUE)

These are the **default apps** that come with Android:

- Dialer
- Email
- Calendar
- Camera
- Settings, etc.
    

> 🧠 These apps are built using the **Java API Framework** and use everything below to work (runtime, libraries, hardware, etc.).

---

## 🧠 How All These Layers Work Together (Real-World Flow):

Here’s what happens when you open the Camera app:

1. You tap the **Camera icon** (a **system app**).
2. Camera app uses **Camera API** from the **Java API Framework**.
3. The **framework talks to HAL**, asking to access the camera
4. HAL passes this to the **camera driver** in the **Linux Kernel**.
5. You take a picture → it may be encoded using **Media Framework (Native C++)**.
6. The app may display it using **OpenGL ES** or **View System**.
7. It runs using **Android Runtime (ART)**.

[for more](https://developer.android.com/guide/platform)
[for more](https://medium.com/mobis3c/introduction-to-android-security-64609edeb18c)

## Android Virtual Machines
Unlike iOS, which compiles Swift/Objective-C into native ARM code, Android wants:

- ⚙ **Cross-platform compatibility**: `.dex` bytecode can run on any device — ARM, x86, etc.
- 🔐 **Security isolation**: Each app runs in a sandboxed VM process.
- 🧹 **Memory management**: ART handles garbage collection automatically.
- 📱 **Process control**: Android can kill/restart background app processes freely.

## What Is Android Runtime (ART)?

- **Android Runtime (ART)** is the engine that runs Android apps.
    
- When an app is built and packaged as an **APK**, it includes `.dex` files (Dalvik Executables).
    
- These `.dex` files contain **bytecode** – a low-level, platform-independent code that ART interprets or compiles into **machine code** (understood by the CPU).
    
- ART is responsible for:
    
    - Converting bytecode → machine code
        
    - Managing memory
        
    - Performing **garbage collection** (though memory is not covered here in detail)
        

---

## 🧠 Compilation Strategies in ART

### 1. **JIT – Just-In-Time Compilation**

> Used in **Dalvik** (pre-Android 5.0)

- Code is compiled **at runtime** — only when needed.
    
- Saves RAM because not all code is compiled upfront.
    
- Downside: **Slower app performance**, because the app is being compiled while running.
    

### 2. **AOT – Ahead-Of-Time Compilation**

> Introduced in **ART (Android 5.0 – Lollipop)**

- Compiles the **entire app into machine code at install time**.
    
- Result: Much **faster runtime performance** (20x faster than JIT).
    
- Downsides:
    
    - Longer **install times**.
        
    - More **RAM usage**.
        
    - Longer **system update times** (as every app had to be recompiled).
        

### 3. **Profile-Guided Compilation**

> Introduced in **Android 7 (Nougat)**

- Reintroduces **JIT** into ART for dynamic compilation.
    
- Combines JIT + AOT for better balance.
    
- Monitors which parts of an app are run frequently ("**hot code**").
    
- These hot methods are **precompiled** for better performance.
    
- Rarely used parts are **compiled only when needed**, saving RAM.
    

---

## ☁️ Profiles in the Cloud

> Introduced in **Android 9 (Pie)**

### Why?

- The first few launches of an app are slower (due to JIT).
    
- ART needs time to collect profile data for each new user.
    

### Solution:

- Google aggregates **usage profiles from other users** of the same app.
    
- Creates a **“common core profile”** of frequently used methods.
    
- This profile is downloaded with the APK and used to precompile code immediately.
    
- Speeds up **first-time app usage**.
    
- Afterward, **user-specific profiles** are collected and used to further optimize performance in the background.

```
1. Java/Kotlin Code
    ↓
2. Compiled to .dex (bytecode)
    ↓
3. ART executes bytecode
    ↓
4. Calls Android Framework APIs (Java layer)
    ↓
5. Android Native Libraries (Skia, MediaCodec, OpenGL ES)
    ↓
6. Android HAL (Hardware Abstraction Layer)
    ↓
7. Linux Kernel (drivers)
    ↓
8. Physical Device Hardware (Display, Camera, GPS)

```

Not all Android apps are written in Java/Kotlin. Some apps (especially games or performance-critical apps) use **C or C++** for speed. These don’t use the Android Runtime (ART) directly — they **bypass the VM** in most cases.

Here’s how it works:

---

### 🔧 **1. Native Code via NDK (Native Development Kit)**

- Android provides a toolset called the **NDK** (Native Development Kit).
- Developers use it to **compile C/C++ code into native binaries** (`.so` files – shared objects).
- These native binaries are included inside the app’s APK under:  
    `lib/armeabi-v7a/` or `lib/arm64-v8a/` etc. (based on architecture)
    
### 2.How the App Is Executed**

#### If the app is written **only in C/C++**:

- It doesn’t need the **Dalvik or ART virtual machine**.
- It runs **directly on the CPU** as native code, just like a normal compiled C program on Linux.
- However, it still interacts with the Android OS through **JNI** (Java Native Interface) or **NDK APIs**.
    

#### If the app is a mix of Java + C/C++:

- Java/Kotlin parts are run via **ART/Dalvik** (VM).
- Native C/C++ parts are called using **JNI**.
- ART handles only the Java/Kotlin code. The **native parts bypass the VM** and run directly.

### Security & Stability Notes

- Native code is **harder to sandbox**, so using C/C++ can increase the risk of memory corruption (buffer overflows, etc.).
- ART provides **better memory safety** and garbage collection for Java/Kotlin code.

[yt video](https://youtu.be/0J1bm585UCc?feature=shared)


## Android Security Model
The Android Security Model is divided into 2 layers
- The first is implemented in the OS and keeps the installed applications fundamentally isolated from one another
- The second is security layer in the application itself. Allows the devs to selectively expose certain application functionalities to other applications

### 1.UID Seperation
**UID separation** in Android refers to the security mechanism where **each application is assigned a unique Linux User ID (UID)** at install time. This UID is used by the Linux kernel to enforce **process-level and file-level isolation**, ensuring that:

- Each app runs in its **own sandbox** (isolated environment),
- **No app can access the data or memory** of another app without proper permission,
- **System-level protections** (like SELinux) enforce strict boundaries between apps, even if they're running on the same system.

### 2. Application Sandboxing
Android sandboxing is a security mechanism that **isolates each app** so it runs in a **separate environment**, preventing access to other apps' data or code.
### 🔹 Key Concepts

- **UID Isolation**: Each app runs as a **unique Linux user (UID)**.
- **File Access Control**: Apps can **only access their own data** in `/data/data/<package>`.
- **Memory Separation**: Each app runs in its **own process with isolated memory**.
- **Native Code Contained**: Even C/C++ code via NDK is sandboxed by the OS.
- **Controlled IPC**: Apps communicate via **intents, services, or content providers**, with permission checks.

### SE Linux 
**SELinux (Security-Enhanced Linux)** is a **mandatory access control system** in Android that enforces **strict rules** about what apps and system processes can access — even if they have the right Linux permissions. It labels everything (apps, files, sockets) and allows actions **only if a policy explicitly permits it**, reducing damage from malware or exploits.
### What’s Involved in SELinux

1. **Security Contexts (Labels)**
    - Every process and file is tagged with a label like `u:r:untrusted_app:s0`.    
2. **Domains (Processes)**
    - Example: `untrusted_app`, `system_server`.    
3. **Types (Objects like files/sockets)**
    - Example: `system_file`, `app_data_file`.    
4. **Policy Rules**
    - Define what a domain can do to a type (e.g., `read`, `write`, `execute`).
5. **Modes**
    - `Enforcing` (blocks violations)
    - `Permissive` (logs only)   
6. **Log & Audit System**
    
    - Denied actions are logged (`avc: denied ...`) for re
[Blog](https://source.android.com/docs/security/features/selinux)


### ADB
ADB stands for Android Debug Bridge, a powerful command line tool that you can use to debug your Android phone or tablet and send a large number of commands to control behavior on the device, allowing for the installation of apps and the logging of processes. To achieve that, the tool is composed of three distinct parts.

First, there is the **client** interface that lives on the machine you use for developing or debugging that sends commands to your device or emulator through the command line terminal. Second, there is a **daemon (ADBD)** that actually executes the commands you send using the client. It runs in the background on all devices and emulators equipped with ADB. Lastly, there is a **server** on your development machine that establishes the connection to your device or emulator.

[Read More](https://medium.com/@EazSoftware/a-comprehensive-guide-to-adb-android-debug-bridge-the-unsung-hero-for-android-developers-28b349037436)
[Cheat Sheet](https://blog.evanemran.info/android-debug-bridge-adb-cheat-sheet)
[Cheat Sheet](https://highon.coffee/blog/adb-command-cheat-sheet/)
