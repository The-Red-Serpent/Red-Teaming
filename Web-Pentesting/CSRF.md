**CSRF (Cross-Site Request Forgery)** is a web security vulnerability that allows an attacker to trick a user into performing actions on a web application **without their knowledge or consent** â€” while the user is authenticated.

### **Conditions for CSRF**

- Victim is **authenticated** (e.g., logged into their bank).
- Victim visits a **malicious site** crafted by the attacker.
- That site makes a **request** to the target web app (bank) using the victimâ€™s **browser + cookies**.
- The web app **trusts** the request because the session cookie is included.


### ğŸ¦ **Real-Life CSRF Scenario â€” Online Banking Transfer**

#### ğŸ­ Actors:

- **Alice** â€“ A user, logged into her online bank: `https://securebank.com`
- **Mallory** â€“ The attacker, hosting `http://evil-hacks.com`
- **SecureBank** â€“ Vulnerable to CSRF (no CSRF tokens or SameSite cookies)
---

### ğŸ“œ **The Situation**

1. **Alice logs into her bank** (`https://securebank.com`) and transfers â‚¹1,000 to a friend. She stays logged in (browser has her session cookie).
2. **Mallory sends Alice a link**, e.g. through:
    - Email
    - A forum post
    - A WhatsApp message
3. **Alice clicks the link** â€” it leads to `http://evil-hacks.com`.
---

### ğŸ’» **The Malicious Page (on `evil-hacks.com`)**

```html
<html>
  <body>
    <h1>Click here to claim your â‚¹5,000 gift card!</h1>
    <img src="https://securebank.com/transfer?to=mallory&amount=5000" style="display:none" />
  </body>
</html>
```

> As soon as the page loads, the `<img>` tag triggers a GET request to the bank, **from Aliceâ€™s browser**, with her **bank cookies**.

---

### âš ï¸ **What Happens Next**

- `https://securebank.com` receives a **valid-looking request**:
    
    ```
    GET /transfer?to=mallory&amount=5000
    Cookie: sessionid=ABC123XYZ  â† (Alice's valid session)
    ```
    
- Since Alice is authenticated, the bank **executes the transfer**, thinking Alice did it.

### âœ… **Why This Worked**

- Bank didnâ€™t use a **CSRF token**.
- Browser **automatically sent session cookies**.
- Alice was **already logged in**.
- Request appeared **legit** from serverâ€™s point of view.

## Common defences against CSRF

#### CSRF Token:
A **CSRF token** is a **random, secret value** generated by the **server** and associated with the **user's session**. It's sent to the client (usually inside an HTML form) and must be included in any **state-changing request** (like POST/PUT/DELETE). 

#### Same Site Cookies:
SameSite prevents the browser from sending this cookie along with cross-site requests. The main goal is to mitigate the risk of cross-origin information leakage. It also provides some protection against cross-site request forgery attacks. Possible values for the flag areÂ `none`,Â `lax`, orÂ `strict`.

- If a cookie is set with `SameSite=Strict`, the browser will only send it when the user is navigating **within the same site**. That means even if the user clicks a link to the site from another domain, the cookie will not be sent. This provides the strongest protection, but can break functionality where cross-site navigation is expected (like clicking a link in an email).

- If the cookie is set to `SameSite=Lax`, the browser will send the cookie in top-level navigations such as clicking a link from another site, but **not** for other types of requests like POST forms, JavaScript fetches, or loading inside iframes. This strikes a balance between security and usability, and itâ€™s the default behavior in most modern browsers if no SameSite value is specified.

- If a cookie is set to `SameSite=None`, it means the browser should always send the cookie, even in cross-site requests. But for this to work, the cookie must also be marked as `Secure`, meaning it can only be sent over HTTPS. This option is usually required when third-party services are involved (like embedded widgets, payment gateways, or single sign-on systems), but it reopens the risk of CSRF if not handled carefully.

#### Referer-based validation:
TheÂ **HTTP Referer**Â header is a request-type header that identifies the address of the previous web page, which is linked to the current web page or resource being requested. The usage of this header increases the risk of privacy and security breaches on a website but it allows websites and web servers to identify where the traffic is coming from.


