Session Fixation is a **web security vulnerability** where an attacker **sets or "fixes" a user's session ID before they log in**. Once the victim logs in, the attacker can hijack the authenticated session because they already know the session ID.

---

## ðŸ§  The Core Idea

A web app uses a **session ID (usually in a cookie)** to track authenticated users. But if the app **doesn't generate a new session ID after login**, then:

- Attacker sets a known session ID for the victim.
    
- Victim logs in using that same session.
    
- Attacker now uses the same ID and is **authenticated as the victim**.
    

---

## ðŸ”“ How Session Fixation Works (Step-by-Step)

### âœ… **Vulnerable flow**

1. **Attacker starts a session** with the app and gets a session ID:  
    `JSESSIONID=abc123`
    
2. **Attacker sends this session ID to the victim** (via phishing, link, iframe, etc):  
    `https://vulnerable-app.com?sessionid=abc123`
    
3. Victim clicks and visits the link â€” the session ID is now set in the browser.
    
4. **Victim logs in**, but the app **does not change** the session ID.
    
5. Since the attacker knows the session ID, they now impersonate the logged-in victim.
    

---

## ðŸ’¥ Real-World Example (Simplified)

```http
# Before login
GET /login HTTP/1.1
Cookie: PHPSESSID=FIXED123

# Victim logs in with this session ID
POST /login HTTP/1.1
Cookie: PHPSESSID=FIXED123
username=admin&password=admin123

# App doesnâ€™t change the session ID
-> Session stays as FIXED123

# Attacker now makes requests with:
Cookie: PHPSESSID=FIXED123
-> Full session hijack.
```

---

## ðŸ›¡ï¸ How to Prevent Session Fixation

### âœ… Regenerate the session ID on login

This is the **main fix**:

```php
// PHP example
session_start();
session_regenerate_id(true); // Generates new ID on login
```

### Other defenses:

- Use **HttpOnly** and **Secure** flags on cookies.
    
- Use **SameSite** to restrict cross-site usage.
    
- Do **not accept session ID from URL/query params.**
    
- Set short expiration time for unauthenticated sessions.
    

---

## ðŸ“Œ Common Places It Happens

- Legacy apps with custom session management
    
- Java apps with JSESSIONID in the URL
    
- Sites that allow session ID via GET parameter

### Some of the most common session fixation attack techniques include:

- Session token in the URL argument
- Session token in a hidden form field
- Session ID in a cookie
---

## ðŸ§ª Testing for Session Fixation

As a pentester:

1. **Manually set a session ID** before login.
    
2. Let the victim log in using that session.
    
3. Try using the same session ID to access the app post-login.
    
If youâ€™re still authenticated â€” **vulnerable**.

## IDENTIFYING SESSION FIXATION

### âœ… Step 1: Understand the app's session handling

You're looking for **how sessions are created, stored, and changed**.

- Open the site in **Burp Suite** (or similar proxy).
    
- Visit any unauthenticated page (e.g., `/login`).
    
- Note the session ID (usually a cookie like `PHPSESSID`, `JSESSIONID`, etc.)
    

http

CopyEdit

`GET /login HTTP/1.1 Cookie: JSESSIONID=abc123`

Take note of:

- The cookie name
    
- Whether itâ€™s passed via **URL, cookie, or POST**
    
- If the cookie is created **before login**
    

---

### âœ… Step 2: Check if the session ID is accepted from the **URL or query parameter**

If the app allows something like:

arduino

CopyEdit

`https://example.com/login?PHPSESSID=attackerID`

â€¦it might be vulnerable. Set a **custom session ID** in the URL and see if the server accepts it.

---

## ðŸ”¬ TESTING SESSION FIXATION

### ðŸ§ª Goal: Confirm if the app allows session fixation **and doesnâ€™t regenerate session ID after login**

---

### ðŸ“Œ Step-by-step test:

### 1. **Get a session ID as the attacker**

Start a session with the application:

h

CopyEdit

`GET /login -> Response: Set-Cookie: PHPSESSID=attacker123`

### 2. **Fix this session for the victim**

Send the victim a link like:

makefile

CopyEdit

`https://example.com/login Cookie: PHPSESSID=attacker123`

Or trick the browser using JavaScript, iframe, or a crafted request.

You can also try:

arduino

CopyEdit

`https://example.com/login?PHPSESSID=attacker123`

(if the app accepts session IDs via URL â€” not common in modern apps).

---

### 3. **Victim logs in with attackerâ€™s session**

Now log in as the victim, using that **same session ID** (`attacker123`).

h

CopyEdit

`POST /login Cookie: PHPSESSID=attacker123 username=victim password=correct_password`

---

### 4. **Check if session ID stayed the same after login**

After login, does the cookie stay as:

ini

CopyEdit

`PHPSESSID=attacker123`

or does it change to something like:

ini

CopyEdit

`PHPSESSID=randomNewValue`

---

### âœ… Vulnerable if:

- The session ID **stays the same** before and after login
    
- The attacker can now use `PHPSESSID=attacker123` to access authenticated pages as the victim
    

---

## ðŸ§ª BURP SUITE Manual Method (Simplified)

1. Go to **Proxy > HTTP history**
    
2. Capture `/login` request before login and see the cookie
    
3. Log in as victim
    
4. Check **post-login response**:
    
    - Did the session cookie change?
        
    - If not: Vulnerable.
        
5. Replay the original session ID and check if you are logged in